{% extends "base.html" %}
{% block content %}

    <style>
      #map-canvas {text-align: center;}
    </style>
    <link href="/static/css/rides.css" rel="stylesheet">
    <script src="https://maps.googleapis.com/maps/api/js?v=3.exp&signed_in=true"></script>
    <script type="text/javascript" src="https://www.google.com/jsapi?autoload={'modules':[{'name':'visualization','version':'1.1','packages':['corechart']}]}"></script>

<script>
var line;

function initialize() {
  getActivity('{{activities[0].id}}', '{{athlete.userid}}', '#activity{{activities[0].id }}');
}

function setMap(a) {

  var mapOptions = {
    mapTypeId: google.maps.MapTypeId.TERRAIN
  };

  var map = new google.maps.Map(document.getElementById('map-canvas'),
      mapOptions);

  var coords = [];

  for (var i = 0; i < a.latitude.length; i++) {
    coords.push(new google.maps.LatLng(a.latitude[i], a.longitude[i]));
  }

  var lineSymbol = {
    path: google.maps.SymbolPath.CIRCLE,
    scale: 8,
    strokeColor: '#FF7519'
  };

  var lineSymbolA = {
    path: google.maps.SymbolPath.CIRCLE,
    scale: 8,
    strokeColor: '#5C005C'
  };

var mapIcons;
if (a['type'] != 'route'){
  mapIcons = [{
    icon: lineSymbol,
    offset: '0%'
  },
  {
      icon: lineSymbolA,
      offset: '0%'
    }]
  }
else {mapIcons = mapIcons = [{
    icon: lineSymbol,
    offset: '0%'
  }]
}
  line = new google.maps.Polyline({
    path: coords,
    strokeColor: '#1da1cc',
    icons: mapIcons,
    map: map
  });

  var sw = new google.maps.LatLng(a['center'][0][0], a['center'][0][1])
  var ne = new google.maps.LatLng(a['center'][1][0], a['center'][1][1])
  var bounds = new google.maps.LatLngBounds(sw, ne)
  map.fitBounds(bounds);

}

google.load('visualization', '1.0', {'packages':['corechart']});

function zip(arrays) {
    return arrays[0].map(function(_,i){
        return arrays.map(function(array){return array[i]})
    });
}
function addCrosshair(x, color) {
    chart.xAxis[0].addPlotLine({
        id: 'xPlotLine'+x,
        value: x,
      width: 2,
      color: color
    });
}

function removeCrosshair(x) {
    chart.xAxis[0].removePlotLine('xPlotLine'+x);
    // chart.yAxis[0].removePlotLine('yPlotLine'+y);
}

function barGauge(xmax) {
  console.log(xmax)
  var chart = new Highcharts.Chart({
            chart: {
                renderTo: 'gauge-bar',
                defaultSeriesType: 'bar',
                animation:false,
                plotBorderWidth: 2,
                plotBorderColor: '#D8D8D8',
                spacingTop: 0,
                spacingLeft: 50,
                spacingRight: 50,
                spacingBottom: 0
            },
            tooltip: {
              enabled: false,
            },
            credits: {
                enabled: false
            },
            xAxis: {
                labels: {
                    enabled: false
                },
                tickLength: 0
            },
            title: {
                text: 'Miles Behind'
            },
            legend: {
                enabled: false
            },
            yAxis: {
                title: {
                    text: null
                },
                labels: {
                    y: 20
                },
                min: -xmax,
                max: xmax,
                tickInterval: xmax/4,
                minorTickInterval: xmax/8
            },
            plotOptions: {
            },
            series: [{
                borderRadius: 3,
                borderWidth: 1,
                pointWidth: 50,
                color: '#FFFF00',
                data: [0]}]
        });
}

function lineChart(a) {

    if (a['type'] == 'route'){
      data = zip([a.plot_predicted_distance, a.plot_predicted_altitude]);
      var ymin = Math.min.apply(null, a.plot_predicted_altitude)
      var ymax = Math.max.apply(null, a.plot_predicted_altitude)
      var xmin = Math.min.apply(null, a.plot_predicted_distance)
      var xmax = Math.max.apply(null, a.plot_predicted_distance)
      var series = [{     
          type: 'area',
          name: 'Altitude',
          yAxis: 0,
          // tooltip: {
          //   pointFormatter: function(){
          //     return '<b>'+ this.series.name +'</b>: '+ Highcharts.numberFormat(this.y, 0, ".", ",") +'<br/>';
          //   }
          // },
          fillOpacity: 0.5,
          data: data,
          lineWidth: 2
        }]
    }
    else {
      data = zip([a.plot_distance, a.plot_altitude]);
      data1 = zip([a.plot_distance, a.streaming_predict]);
      var ymin = Math.min.apply(null, a.plot_altitude)
      var ymax = Math.max.apply(null, a.plot_altitude)
      var xmin = Math.min.apply(null, a.plot_distance)
      var xmax = Math.max.apply(null, a.plot_distance)
      var series = [
        {     
          type: 'area',
          name: 'Altitude',
          yAxis: 0,
          // tooltip: {
          //   pointFormatter: function(){
          //     return '<b>'+ this.series.name +'</b>: '+ Highcharts.numberFormat(this.y, 0, ".", ",") +'<br/>';
          //   }
          // },
          fillOpacity: 0.5,
          data: data,
          lineWidth: 2
        },
        {
          type: 'spline',
          name: 'Streaming Prediction',
          yAxis: 1,
          // tooltip: {
          //   pointFormatter: function(){
          //     return '<b>'+ this.series.name +'</b>: '+ moment.utc(this.y*1000).format("HH:mm:ss") +'<br/>';
          //   }
          // },
          data: data1,
          lineWidth: 2
        },
        {
          type: 'line',
          name: 'Predicted Time',
          yAxis: 1,
          data: [[-100, a.moving_time], [600, a.moving_time]]
        }]
    }
    console.log(series)
        chart = new Highcharts.Chart({
            chart: {
                renderTo: 'container',
                spacingTop: 0,
                spacingLeft: 0,
                spacingRight: 0,
                spacingBottom: 0
            },
            tooltip: {
                formatter: function() {
                    var s = ['<b>Distance</b>: '+ Highcharts.numberFormat(this.x, 2, ".", ",")];

                    $.each(this.points, function(i, point) {
                      if (point.series.name === 'Altitude'){
                        text = '<b>'+ point.series.name +' : '+
                            Highcharts.numberFormat(point.y, 0, ".", ",") +'</b>';
                      }
                      else {
                        text = '<b>'+ point.series.name +'</b>: '+ moment.utc(this.y*1000).format("HH:mm:ss") +'<br/>';
                      }
                        s.push(text);
                    });

                    return s.join('<br>');
                },
                shared: true,
                crosshairs: true,
            },
            xAxis: {
              min: xmin,
              max: xmax,
                title: {
                    enabled: true,
                    text: 'Distance (mi)'
                },
                ordinal: false
            },
            yAxis: [{
                min: ymin,
                max: ymax,
                title: {
                    text: 'Altitude (ft)'
                }
            },
            {
                title: {
                    text: 'Time (s)'
                },
                labels: {
                  formatter: function(){
                    return moment.utc(this.value*1000).format("HH:mm:ss")
                    // return this.value + 's'
                  }
                },
                opposite: true
            }],
            title: {
                text: 'Ride profile'
            },
            plotOptions: {
                    series: {
                        compare: 'percent'
                    }
                },
            series: series
        });
};

function simRide(a) {
    
    // document.getElementById("ride-console").style.visibility = "visible";
    if (a.type != 'route') {
      document.getElementById("gauges").style.width="auto";
      document.getElementById("gauges").style.height="100px";
      document.getElementById("gauges").style.textAlign="center";
      document.getElementById("gauges").innerHTML = '<div id="gauge-bar" style="height: 70px;margin:0px auto;"></div>';
      var xmin = Math.min.apply(null, a.distance_diff)
      var xmax = Math.max.apply(null, a.distance_diff)
      xmax = Math.max(Math.abs(xmin), Math.abs(xmax))
      xmax = Math.round(xmax*2)/2;
      barGauge(xmax)
    }
    
    var count = 0;
    d = a['plot_distance'];
    pd = a['plot_predicted_distance'];
    var duration = moment.duration(0, 'seconds');
    pidx = 0;
    idx = 0;

    spacing = 20;
    timeStep = 100;

    simInterval = window.setInterval(function() {
      var isDone = false
      var icons = line.get('icons');

      if (a['type'] != 'route'){
        if (count != 0){
          removeCrosshair(a.plot_distance[idx])
          removeCrosshair(a.plot_predicted_distance[pidx])
        }
        idx = Math.min(count, d.length -1)
        pidx = Math.min(count, pd.length -1)
        offset = d[idx]*100.0/a.total_distance
        poffset = pd[pidx]*100.0/a.total_distance

        icons[0].offset = offset + '%';
        icons[1].offset = poffset + '%';
        
        addCrosshair(a.plot_distance[idx], '#FF7519')
        addCrosshair(a.plot_predicted_distance[pidx], '#5C005C')

        gauge = $('#gauge-bar').highcharts();
          if (gauge) {
              var transition = false;
              if (idx != 0){
                var previousDiff = a.distance_diff[idx - spacing];
              }
              else {
                var previousDiff = 0;
              }
              if (a.distance_diff[idx] >= -xmax*0.25 && previousDiff < -xmax*0.25) {
                // red to yellow
                gauge.series[0].options.color = '#FFFF00';
                transition = true;
              }
              else if (a.distance_diff[idx] >= xmax*0.25 && previousDiff < xmax*0.25) {
                // yellow to green
                gauge.series[0].options.color = '#393';
                transition = true;
              }
              else if (previousDiff >= xmax*0.25 && a.distance_diff[idx] < xmax*0.25) {
                // green to yellow
                gauge.series[0].options.color = '#FFFF00';
                transition = true;
              }
              else if (previousDiff >= -xmax*0.25 && a.distance_diff[idx] < -xmax*0.25) {
                //yellow to red
                gauge.series[0].options.color = '#F00';
                transition = true;
              }
              if (transition){
                gauge.series[0].update(gauge.series[0].options);
              }
              point = gauge.series[0].points[0];
              point.update(a.distance_diff[idx]);
            }
        

        if ((count > d.length) & (count > pd.length)) {
          removeCrosshair(a.plot_distance[idx])
          removeCrosshair(a.plot_predicted_distance[pidx])
          console.log('cleared')
          clearInterval(simInterval)
        }
      }
      else {
        if (count != 0){
          removeCrosshair(a.plot_predicted_distance[pidx])
        }

        pidx = Math.min(count, pd.length - 1);
        poffset = pd[pidx]*100.0/a.total_distance
        icons[0].offset = poffset + '%';
        addCrosshair(a.plot_predicted_distance[pidx], '#5C005C')
        if (count > pd.length){
          console.log('cleared')
          removeCrosshair(a.plot_predicted_distance[pidx])
          clearInterval(simInterval)
        }
      }
      line.set('icons', icons);
      duration = moment.duration(a.plot_time[count]*1000, 'seconds');



      

        // document.getElementById('ride-console').innerHTML = '<br/><table><tr>' + 
        // '<td>Time: ' + moment.utc(a.plot_time[count]*1000).format("HH:mm") + '</td>' +
        // '<td>Time: ' + moment.utc(a.plot_time[count]*1000).format("HH:mm") + '</td>' +
        // '<td>Time: ' + moment.utc(a.plot_time[count]*1000).format("HH:mm") + '</td>' +
        // '</tr></table><br/>'
        // document.getElementById('playback-margin').innerHTML = (d[count] - pd[count]).toFixed(2);
        // document.getElementById('playback-distance').innerHTML = d[count].toFixed(2);
      // }
      count = count + spacing;
  }, timeStep);
}

function getActivity(aid, uid, activityElement) {
  $.post('/change', {
        activity_id: aid,
        athlete_id: uid
    }).done(function(response){
      switchActivity(response)
    }).fail(function() {
        console.log('fail');
    });
}

function deleteRoute(rid, uid, routeElement) {
  $.post('/delete/route', {
        route_id: rid,
        athlete_id: uid
    }).done(function(response){
      var row = document.getElementById('route' + rid.toFixed());
      row.parentNode.removeChild(row);
    }).fail(function() {
        console.log('fail');
    });
}

function switchActivity(a) {
  document.getElementById("gauges").innerHTML = '<div style="height: 0px"></div>'
  activity = a
  $(document.getElementById('activity_desc')).text(a['name']);
  $(document.getElementById('activity_date')).text(a['date']);
  $(document.getElementById('activity_rating')).text(a['ride_rating'][1]);
  $(document.getElementById('activity_start')).text(a['start_time']);
  $(document.getElementById('activity_moving_time')).text(a['moving_time_string']);
  $(document.getElementById('activity_pred_time')).text(a['predicted_total_time']);
  if (typeof simInterval !== 'undefined') {
    clearInterval(simInterval)
  }
  if (typeof chartInterval !== 'undefined') {
    clearInterval(chartInterval)
  }
  setMap(a)
  lineChart(a)
}

function uploadRoute(){
  console.log('asdfdasf')
  document.getElementById('route-upload').innerHTML = '<form enctype="multipart/form-data" action="/upload" method="POST" id="upload-form">' + 
      '<input type="hidden" value="{{athlete.userid}}" name="athlete_id">' + 
      '<p>Ride description: '+
      '<input type="text" name="ride_title" size="3"></p>'+
      '<input name="file" type="file" accept=".gpx"/><br />'+
      '<input type="submit" value="Upload">'+
      '</form>';
  document.getElementById("route-upload").style.visibility = "visible";
}

      google.maps.event.addDomListener(window, 'load', initialize);

    </script>
    <style type="text/css">
      .map { margin: 0 auto 0 auto; }
      .wrapper {text-align: center;
                padding: 5px 5px 5px 5px;
               }
    </style>
    <div class="row">
    <div class='span7 main' style="margin-left: 52px;">

      <table>
        <thead><th colspan="2">Ride Summary</th></thead>
        <tr><td>Rider:</td><td>{{athlete.name}}</td></tr>
        <tr><td>Ride:</td><td><span id="activity_desc">{{activity.name}}</span></td></tr>
        <tr><td>Date:</td><td><span id="activity_date">{{activity.dt.strftime("%A %B %d, %Y")}}</span></td></tr>
        <tr><td>Start Time:</td><td><span id="activity_start">{{activity.dt.strftime("%H:%M:%S %p")}}</span></td></tr>
        <tr><td>Total Time:</td><td><span id="activity_moving_time">{{activity.moving_time_string}}</span></td></tr>
        <tr><td>Predicted Time:</td><td><span id="activity_pred_time">{{activity.predicted_moving_time}}</span></td></tr>
        <tr><td>Ride Rating:</td><td><span id="activity_rating"></span></td></tr>
      </table>
      <div class="wrapper">
          <button id="play" onclick="simRide(activity)">Play Ride</button>
      </div>
      
      <div class="map" id="map-canvas" style="width:700px;height:380px;"></div>
      <div id="ride-console" style="visibility: hidden;">
      </div>
      <br>
      <div id="gauges"></div>
      <div id="container" style="min-width: 310px; height: 250px; max-width: 800px; margin: 0 auto"></div>
    </div>
      <div class='span1 main'></div>
      <div class='span7 main'>

      <div><h4 style="float: left;">Your routes</h4>
      <div style="float: right;" id="route-upload"><p><a class='button' onclick="uploadRoute()">Upload a Route</a></p></div></div>
      <table align="right">
        <thead>
          <th>Ride Name</th>
          <th>Date</th>
          <th>Distance</th>
          <th></th>
          <th></th>
        </thead>
      {% for r in routes %}
      <tr id="route{{r.id}}">
        <td><a href="javascript:getActivity({{r.id}}, {{athlete.userid}}, '#activity{{ r.id }}');">{{r.name}}</a></td>
        <td>{{r.dt.strftime("%B %d, %Y")}}</td>
        <td>{{(r.total_distance / 1609.34)|round(0, 'floor')}}</td>
        <td><a href="/compare/{{r.id}}/{{athlete.userid}}">See how you stack up<a/></td>
        <td><a href="javascript:deleteRoute({{r.id}}, {{athlete.userid}}, '#activity{{ r.id }}');">delete</a></td>
      </tr>
      {% endfor %}
      </table>

      <h4>Your completed activities</h4>
      <table align="right">
        <thead>
          <th>Ride Name</th>
          <th>Date</th>
          <th>Distance</th>
          <th></th>
        </thead>
      {% for a in activities %}
      <tr>
        <td><a href="javascript:getActivity({{a.id}}, {{athlete.userid}}, '#activity{{ a.id }}');">{{a.name}}</a></td>
        <td>{{a.dt.strftime("%B %d, %Y")}}</td>
        <td>{{(a.total_distance / 1609.34)|round(0, 'floor')}}</td>
        <td><a href="/compare/{{a.id}}/{{athlete.userid}}">See how you stack up<a/></td>
      </tr>
      {% endfor %}
    </table>
  </div>
</div>
<script type="text/javascript" src="https://www.google.com/jsapi?autoload={'modules':[{'name':'visualization','version':'1.1','packages':['corechart']}]}"></script>

    <script type="text/javascript" charset="utf-8">
      $(document).ready(function() {
        $("table").tablecloth({
          theme: "stats",
          striped: true,
          sortable: true,
          condensed: true,
          clean: true
        });
      });
    </script>
  <!-- </body> -->


{% endblock %}